use Libraries.Game.Game
use Libraries.Containers.Array
use Libraries.System.File
use Libraries.System.FileReader
use Libraries.Game.Graphics.Drawable
use GameObject


class GameRoom
    private GameObjects obj
    private Array<GameObject> g_objs
//    private Array<GameObject> g_deleted_objs_queue
//    private Array<GameObject> g_added_objs_queue
    public integer pg_ScreenSizeX = 1000  // Default width of room
    public integer pg_ScreenSizeY = 320   // Default height of room
    private integer g_GridX = 40          // This is the width  of each 'grid' on map
    private integer g_GridY = 40          // This is the height of each 'grid' on map
    
    // Camera Variables
    public integer pg_CamXOffset = 0
    public integer pg_CamYOffset = 0
    public integer pg_CamMaxXOffset = 0
    public integer pg_CamMaxYOffset = 0
    public integer pg_CamReset = 0        // Set to one so main knows to reset cam

/*    action QueueAddObj (GameObject tmpObj)
        g_added_objs_queue:AddToEnd(tmpObj)
    end

    action DequeueAddObj
        returns GameObject
        g_objs:AddToEnd(g_added_objs_queue:RemoveFromFront())
        return g_objs:GetFromEnd()
    end

    action GetAddQueueSize
        returns integer
        return g_added_objs_queue:GetSize()
    end

    action QueueDelObj (integer objIndex)
        GameObject tmpObj = g_objs:Get(objIndex)
        g_objs:RemoveAt(objIndex)
        g_deleted_objs_queue:AddToEnd(tmpObj)
    end

    action QueueDelObj (GameObject obj)
        g_objs:RemoveAt(GetIndexOfObj(obj))
        g_deleted_objs_queue:AddToEnd(obj)
    end

    action DequeueDelObj
        returns GameObject
        return g_deleted_objs_queue:RemoveFromFront()
    end

    action GetDelQueueSize
        returns integer
        return g_deleted_objs_queue:GetSize()
    end*/

    action GetObjCount
        returns integer
        return g_objs:GetSize()
    end

    // returns the first index of obj found with name
    // if none are found, returns -1
    action GetIndexOfObj (text objName)
        returns integer

        i = g_objs:GetSize()
        repeat until i = 0
            if (g_objs:Get(i-1):GetName():Contains(objName))
                return i - 1 // obj found, return index
            end
            i = i - 1
        end

        // returns -1 if obj not found
        return -1
    end

    // returns the index of obj found
    // if non are found, returns -1
    action GetIndexOfObj (GameObject tmpObj)
        returns integer
        i = g_objs:GetSize()
        repeat until i = 0
            if (g_objs:Get(i-1):Equals(tmpObj))
                return i - 1 // obj found, return index
            end
            i = i - 1
        end

        // returns -1 if obj not found
        return -1
    end

    action GetObjAtIndex (integer index)
        returns GameObject
        return g_objs:Get(index)
    end

    action DeleteObjAtIndex (integer index)
        g_objs:RemoveAt(index)
    end

    action AddRoomToGame(Game game)
        integer i = 0
        repeat while i < g_objs:GetSize()
	    g_objs:Get(i):AddToGame(game)
            i = i + 1
        end
    end

    action RemoveRoomFromGame(Game game)
        integer i = 0
        repeat while i < g_objs:GetSize()
	    g_objs:Get(i):RemoveFromGame(game)
            i = i + 1
        end
    end

    action LoadRoomFromFile(text roomTextPath, GameObject_Library BlockLib)

        // Open the map file find the line after [MAP] and place in readLine
        File f  
        f:SetPath(roomTextPath)
        LoadRoomFromFile(f, BlockLib)
    end

    action LoadRoomFromFile(File TargetFile, GameObject_Library BlockLib)
        text readLine = ""
        number currentY = 0

        // Open the map file find the line after [MAP] and place in readLine
//        File f  
//        f:SetPath(roomTextPath)
        FileReader reader
        reader:OpenForRead(TargetFile)
        repeat until readLine = "[MAP]" and not reader:IsAtEndOfFile()
            readLine = reader:ReadLine()
        end
        readLine = reader:ReadLine()

        repeat until readLine = "[MAPEND]" and not reader:IsAtEndOfFile()
            Array<text> tmpArray = readLine:Split(",")
            i = 0
            text myMap = ""
            repeat until i = tmpArray:GetSize()
                if tmpArray:Get(i) not= " "     // don't create a blank object
		    GameObject NewObject = BlockLib:GetGameObject(tmpArray:Get(i))
		    NewObject:SetStartPosition(i*g_GridX, pg_ScreenSizeY-(currentY*g_GridY)-g_GridY)
		    NewObject:RefreshGameObject()
		    g_objs:Add(NewObject)
                end
                myMap = myMap + tmpArray:Get(i)
                i = i + 1
            end
            //output myMap + " " + (pg_ScreenSizeY-(currentY*g_GridY)-g_GridY)
            currentY = currentY + 1

            readLine = reader:ReadLine()
        end
        reader:Close()
    end

    action UnloadRoom
        g_objs:Empty()
    end

    action ResetCamera
/*        integer i = GetObjCount()
        repeat until i = 0
            QueueDelObj(i - 1)
            i = i - 1
        end*/
        

        // Reset Camera
        pg_CamXOffset = 0
        pg_CamYOffset = 0
        pg_CamMaxXOffset = 0
        pg_CamMaxYOffset = 0
        pg_CamReset = 1
    end

end